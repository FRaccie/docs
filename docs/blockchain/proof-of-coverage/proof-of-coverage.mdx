---
id: proof-of-coverage
hide_title: true
sidebar_label: Proof of Coverage
slug: /blockchain/proof-of-coverage
---

import useBaseUrl from '@docusaurus/useBaseUrl'

<img
  className="docsheader"
  src={useBaseUrl('img/blockchain/proofofcoverage.png')}
/>

## Proof of Coverage

The Helium blockchain uses a novel work algorithm called “Proof of Coverage” (PoC) to verify that Hotspots are located where they claim. Put another way, PoC tries to verify, on an ongoing basis, that Hotspots are honestly representing their location and the wireless network coverage they are creating from that location.

<!--**See Proof of Coverage in Action**-->

<!--The [Helium Network Explorer](https://network.helium.com) is the best resources for viewing-->

<!--POC-related data. Before you dive into the POC internals, here are a few PoC Challenges to help you-->

<!--visualize how this works:-->

<!-- -[Cheesy Brick Mustang from block 641265](https://explorer.helium.com/txns/qmJF48v8ZlEfsPg_7jc2CrsLlOvgC7w-pvB_BWQAoOk)-->

<!-- -[Plain Mocha Mouse from block 643923](https://explorer.helium.com/txns/kQVfUV88j3s1Glj4fRXFb5MqBeFdTq8ILK2RlaFTnvQ)-->

## Why Proof of Coverage?

The Helium Network is a [physical wireless network](https://explorer.helium.com) that succeeds based on the reliable coverage it can create for users deploying connected devices. As such, it required a working algorithm built for this use case. Proof-of-Coverage takes advantage of radio frequency's (RF) unique, undeniable properties to produce meaningful proofs to the Helium Network and its participants. Specifically, PoC relies on the following characteristics:

- RF has limited physical propagation and, therefore, distance.
- The strength of a received RF signal is inversely proportional to the square of the distance from the transmitter.
- RF travels at the speed of light with (effectively) no latency.

The Helium blockchain uses these properties to interrogate Hotspots using a "PoC Challenge" mechanism. The ultimate power of Proof-of-Coverage lies in the fact that the data generated by the ongoing proofs is a conclusive verification of the wireless coverage provided by Hotspots on the Network.

## Off-Chain Proof-of-Coverage

<!--TODO: add content from announcement blog and other sources-->

Off-Chain Proof-of-Coverage (PoC) is a new way for IOT Hotspots to participate in Proof-of-Coverage. Previously, Proof-of-Coverage challenges were created by Validators and then delivered to Hotspots as requests to Beacon. This process was random and unpredictable on small time scales. On average, however, a Hotspot could expect to receive a challenge only once every couple of days.

## Proof-of-Coverage Challenges

The "challenge" is the discrete unit of work for Proof of Coverage. To date, 10s of millions of challenges have been issued and processed by the Helium blockchain. With each new challenge, the blockchain records more data about the quality of the network. Let's take a look at how challenges happen.

PoC Challenges involve three distinct roles:

### Beaconer

Sometimes called "Challengee." This Hotspot is the target of the POC challenge and is responsible for transmitting (or "beaconing") challenge packets to be witnessed by geographically proximate Hotspots.

### Witness

Hotspots that are geographically proximate to the Beaconer and report the existence of the transmitted challenge packet. Any Light Hotspot hearing the transmitted packet will serve as a Witness as we have today on the Helium Network. Light Hotspots submit their Witness report over gRPC.

<!--The Witnessing Hotspot uses the Validator(s) they are connected to as a client to lookup the Challenger Validator by the hash of the PoC packet. The Light Hotspot then uses this routing information to directly submit the Witness receipt to the Challenger.-->

The Challenger, after the `poc_timeout` number of blocks, will create a `blockchain_txn_poc_receipts_v2` transaction, using received Challengee receipts and Witness reports, and submit it to the blockchain thereby completing the PoC challenge.

### Oracles

Oracles are powerful machines that ingest completed challenges, verify the challenge and witness validity, and then inject the results back into the Helium L1 blockchain for rewards to be issued. Oracles interact with data and systems outside of a native blockchain environment, providing a solution to a fundamental limitation of smart contracts.

<!--TODO: add information here -->

:::info History of PoC Roles

The Consensus Group, a group of Hotspots elected by the blockchain to progress block production, issued challenges in early iterations of the PoC algorithm. Eventually, as the number of active Hotspots grew, [HIP-55](https://github.com/helium/HIP/blob/main/0055-validator-challenges.md) was proposed and voted on by the community to move Consensus Groups, and the "Challenger" role to Validators, much more powerful machines capable of handling the ever-growing volume of data and connections on the Network.

Even farther back in history, and before [HIP-15](https://github.com/helium/HIP/blob/master/0015-beaconing-rewards.md), Proof of Coverage relied entirely on beaconing. A beacon was a single transmission witnessed by any Hotspot. Previous versions used multi-hop challenge paths that didn't accurately test Hotspots' ability to capture RF packets.

:::

## PoC Reward Scaling

For every epoch, each [reward type](/blockchain/mining) is split amongst Hotspots who had a role in that reward pool.

For example, if your Hotspot was challenged during an epoch, it will be eligible to a portion of the 5.31% of rewards that go to PoC Transmitters. A practical way of thinking about this is that a Hotspot might earn a "reward unit" for succeeding at a challenge. If five additional Hotspots succeeded at a challenge during the epoch and each of them also earned a "reward unit", then each Hotspot gets 1/6th of the 5.31% of rewards in that epoch.

With the activation of [HIP-15](https://github.com/helium/HIP/blob/master/0015-beaconing-rewards.md) and [HIP-17](https://github.com/helium/HIP/blob/master/0017-hex-density-based-transmit-reward-scaling.md), we introduced the idea of scaling these "reward units", so the units earned when being witnessed or witnessing a packet scale depending on two things:

1. The number of witnesses, detailed in HIP15
2. The number of Hotspots in the hex tile of the transmitter, detailed in HIP17

The HIPs themselves provide a rich explanation of these mechanisms, so you're encouraged to read those, but they can be summarized as follows:

**From HIP-15**

- For the Transmitters, the more witnesses, the more the Transmitter earns;
- For the Witness, each additional witness past a total of four reduces what is earned by each witness in that challenge.
- A change made with the 2021.09.14.0 release randomly shuffles the valid received witness receipts, and selects (up to) 25 of those valid to write to the chain.

**From HIP-17**

- The Witness earns less if the number of Hotspots in the area of the Transmitter exceeds the "target density". Target density varies by hex resolution, as detailed in the HIP and defined in several chain variables.

### Attestation and Slashing enablement

All messages originating from a Validator containing an assertion about the blockchain will be attested. This includes messages not described in this document.

If a Light Hotspot receives a message from a Validator and needs to act on it (e.g., contacting a Challenger Validator to submit receipts) the Light Hotspot will include the attestation in its request to that Challenger Validator. The attestation provides evidence on behalf of the Light Hotspot to the Challenger Validator that it received the instruction and/or data that resulted in the said action.

If the Challenger Validator member determines the instruction/data was spurious in nature, unsolicited, or otherwise untrustworthy then the member can decide to act on this. This allows for future implementations where the verifiably false assertion is published, with the malicious Validator's attestation, to allow for slashing of the Validator's stake.

Similarly, Light Hotspots themselves, if they determine the message received from a Validator is untrustworthy, can build their own untrusted list of Validators.
